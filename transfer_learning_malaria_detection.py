# -*- coding: utf-8 -*-
"""Transfer_Learning_Malaria_Detection.ipynb

Automatically generated by Colaboratory.

"""

#Mounting the google drive to access it in google colab
# from google.colab import drive
# drive.mount('/content/drive/')

import keras

#import the required libraries and methods
from keras.layers import Input, Lambda, Dense, Flatten
from keras.models import Model
from keras.applications.vgg19 import VGG19
from keras.applications.vgg19 import preprocess_input
from keras.preprocessing import image
from keras.preprocessing.image import ImageDataGenerator
from keras.models import Sequential
import numpy as np
from glob import glob
import matplotlib.pyplot as plt

#Dimensions of one image
ImgSize = [224, 224]
#To get the location of "malaria detection cell images" dataset in the drive
train_path = 'Dataset/Train'
test_path = 'Dataset/Test'

# add preprocessing layer to the front of VGG
#include_top=False argument is to load a network that doesn't include the classification layers at the top, which is ideal for feature extraction.
vgg = VGG19(input_shape=ImgSize + [3], weights='imagenet', include_top=False)

# don't train existing weights
# VGG19 has many layers, so setting the entire model's trainable flag to False will freeze all the layers
for layer in vgg.layers:
    layer.trainable = False

# To get the no. of classes (Uninfected, Parasite cells)
folders = glob('Dataset/Train/*')
print(folders)

x = Flatten()(vgg.output)
prediction = Dense(len(folders), activation='softmax')(x)

# create a model object
model = Model(inputs=vgg.input, outputs=prediction)

# view the structure of the model
model.summary()

# tell the model what cost and optimization method to use
model.compile(
    loss='categorical_crossentropy',optimizer='adam',metrics=['accuracy']
)

# Use the Image Data Generator to import the images from the dataset in the drive
from keras.preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(rescale = 1./255,
                                   shear_range = 0.2,
                                   zoom_range = 0.2,
                                   horizontal_flip = True)

test_datagen = ImageDataGenerator(rescale = 1./255)

training_set = train_datagen.flow_from_directory('Dataset/Train',
                                                 target_size = (224, 224),
                                                 batch_size = 32,
                                                 class_mode = 'categorical')

test_set = test_datagen.flow_from_directory('Dataset/Test',
                                            target_size = (224, 224),
                                            batch_size = 32,
                                            class_mode = 'categorical')

# fit the model
m = model.fit_generator(
  training_set,
  validation_data=test_set,
  epochs=6,
  steps_per_epoch=len(training_set),
  validation_steps=len(test_set)
)

# plot the loss 
plt.plot(m.history['loss'], label='train loss')
plt.plot(m.history['val_loss'], label='validation loss')
plt.legend()
plt.show()
plt.savefig('LossVal_loss')

# plot the accuracy
plt.plot(m.history['accuracy'], label='train accuracy')
plt.plot(m.history['val_accuracy'], label='validation accuracy')
plt.legend()
plt.show()
plt.savefig('AccVal_acc')

#Saving this state of the model as h5 file
model.save('malaria_vgg19.h5')

#Loading the saved model (malaria_vgg19.h5) to do the testing on test data
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
model=load_model('malaria_vgg19.h5')

#Loading one image from test data 
img=image.load_img('Dataset/Test/Uninfected/2.png',target_size=(224,224))
x=image.img_to_array(img)
x.shape

x=x/255
x=np.expand_dims(x,axis=0)
img_data=preprocess_input(x)
img_data.shape

model.predict(img_data)

a=np.argmax(model.predict(img_data), axis=1)

if(a==1):
    output_label="Uninfected"
else:
    output_label="Infected"
print(output_label)

model.layers[0].input_shape

image_path="Dataset/Test/Uninfected/2.png"
img1 = image.load_img(image_path, target_size=(224, 224))
plt.imshow(img1)
img1 = np.expand_dims(img, axis=0)
result=model.predict(img1)
plt.title('{0}  {1}'.format(output_label,result[0][0]))
plt.show()